{
    "showMessages": {
        "label": "Show Messages",
        "icon": "messageboard.png",
        "summary": "Display warnings and errors in the Message Board",
        "description": "The message board provides information about warnings and critical errors that have occurred during the current Maya session. They are indicated by the (1) number of the Ragdoll menu."
    },

    "activeRigid": {
        "deprecated": true,
        "label": "Active Rigid",
        "icon": "rigid.png",
        "summary": "Customise the creation of a new rigid body.",
        "description": "The rigid body, this outputs the translate and rotate channels that typically plug into your animation control. It lives as a shape, underneath your control, and is accessible via the Channel Box.<br><br>Rigids either output or input a transform. The *active* rigid outputs a transform, passing information from solver into your Maya scene.",
        "media": [
            {
                "label": "Basics",
                "description": "Turn any native Maya polygon or NURBS object into a rigid by selecting it and clicking 'Active Rigid'.",
                "fname": "rigid.gif"
            },
            {
                "label": "Multiple Selection",
                "description": "When two or more objects are selected - whether it be polygons, NURBS or joints - they'll all be turned into rigids.",
                "fname": "rigid_multiselect.gif"
            },
            {
                "label": "Blend Existing Animation",
                "description": "If the selected node(s) are animated, the animation can be used as a target for the subsequent simulation using the 'Blend' option.",
                "fname": "rigid_blend.gif"
            },
            {
                "label": "Blend and Edit",
                "description": "Once turned into rigids, your original animation remains intact and can be edited just like before. You can also blend between the original input and final simulation via the `blendSimulation` node.",
                "fname": "rigid_blendedit.gif"
            }
        ],
        "options": [
            "solver",
            "createRigidType",
            "existingAnimation",
            "initialShape",
            "computeMass2",
            "addUserAttributes",
            "rigidSelect"
        ]
    },
    "activeChain": {
        "deprecated": true,
        "label": "Active Chain",
        "icon": "chain.png",
        "summary": "Create a series of connected rigid bodies.",
        "description": "Use this to represent limbs of a character. It also supports tree-like hierarchies, like two arms connected to a spine.",
        "options": [
            "solver",
            "chainShapeType",
            "computeMass2",
            "chainPassiveRoot",
            "chainAutoMultiplier",
            "chainAutoLimits"
        ]
    },
    "passiveRigid": {
        "deprecated": true,
        "label": "Passive Rigid",
        "icon": "collider.png",
        "summary": "Customise the creation of a new passive rigid body.",
        "description": "The passive rigid body feeds data from your animation control to Ragdoll, rather than the other way around like the Active Rigid. It's used to pass animation straight into the solver, without modifying it with forces or contacts. That also means passive rigids can travel straight through other rigids if not careful. You can think of a Passive Rigid as a physical object of infinite mass; nothing gets in its way.",
        "media": [
            {
                "label": "Basics",
                "description": "Turn any polygonal, NURBS surface or joint into a rigid which can be animated but isn't affected by the simulation.",
                "fname": "rigid_passive.gif"
            }
        ],
        "options": [
            "solver",
            "initialShape"
        ]
    },
    "tissue": {
        "deprecated": true,
        "label": "Tissue",
        "enable": false
    },
    "cloth": {
        "deprecated": true,
        "label": "Cloth",
        "enable": false
    },
    "muscle": {
        "deprecated": true,
        "label": "Muscle",
        "icon": "muscle.png",
        "summary": "Make a muscle from the selected anchor points.",
        "description": "The muscle is a regular Active Rigid with two additional Point Constraints added to either end. The benefit is simply less clicks required.",
        "options": [
            "muscleAimAxis",
            "muscleUpAxis",
            "muscleFlex",
            "muscleRadius"
        ]
    },
    "fluid": {
        "deprecated": true,
        "label": "Fluid",
        "enable": false
    },
    "constraint": {
        "deprecated": true,
        "label": "Constraint",
        "icon": "constraint.png",
        "summary": "Constrain one rigid to another.",
        "description": "These are the primary way in which to achieve a desired motion or behavior of a rigid. They establish a relationship between exactly two rigid bodies and either limit the motion of a child relative some parent, and/or drive a child rigid into some position and orientation of a parent rigid.<br><br>Constraints can be made to the scene itself, in which case you can think of it as a worldspace constraint. This is mostly used/useful for guided simulation in worldspace. The same effect can however be achieved by constraining to any Passive Rigid, as the Scene is technically just a passive rigid with some additional attributes.",
        "options": [
            "constraintType",
            "constraintOutlinerStyle",
            "maintainOffset",
            "autoOrient",
            "constraintGuideStrength"
        ]
    },
    "point": {
        "deprecated": true,
        "label": "Point",
        "icon": "point_constraint.png",
        "summary": "Constrain the position of two rigid bodies."
    },
    "orient": {
        "deprecated": true,
        "label": "Orient",
        "icon": "orient_constraint.png",
        "summary": "Constrain the orientation of two rigid bodies.",
        "description": "Constrain the orientation of two rigid bodies. This doesn't have a physical equivalent, as you can't have something rotate the same as another object without also having some sort of positional relationship."
    },
    "parent": {
        "deprecated": true,
        "label": "Parent",
        "icon": "parent_constraint.png",
        "summary": "Constrain both the position and orientation of two rigid bodies.",
        "description": "Constrain both the position and orientation of two rigid bodies. Useful for when you need multiple shapes for a single rigid."
    },
    "hinge": {
        "deprecated": true,
        "label": "Hinge",
        "icon": "hinge_constraint.png",
        "summary": "A special kind of Socket Constraint",
        "description": "A special kind of Socket Constraint where the X-axis (a.k.a. 'twist') is rotated 90 degrees. This constraint is especially well grouped for hinge-like appendages, like elbows and knees."
    },
    "socket": {
        "deprecated": true,
        "label": "Socket",
        "icon": "socket_constraint2.png",
        "summary": "Constrain the position and limit the orientation between two rigid bodies.",
        "description": "Constrain the position and limit the orientation between two rigid bodies. Useful for things like shoulder and hip joints."
    },
    "ignoreContacts": {
        "deprecated": true,
        "label": "Ignore Contacts",
        "icon": "ignore_contacts.png",
        "summary": "Ignore contacts between the two selected rigids.",
        "description": "This is a normal constraint with limits and guides disabled, and 'Allow Overlap' left enabled."
    },
    "animationConstraint": {
        "deprecated": true,
        "label": "Animation Constraint",
        "icon": "animation.png",
        "summary": "Convert translate/rotate channels into a target guide.",
        "description": "Turn the animatable translate and rotate channels into a suitable guide target pose."
    },
    "hardPin": {
        "deprecated": true,
        "label": "Hard Pin",
        "icon": "hardpin.png",
        "summary": "Pin a rigid body in worldspace.",
        "description": "Pin the selected rigid body at its current worldspace position. The pin may be animated and disabled/enabled at run-time."
    },
    "softPin": {
        "deprecated": true,
        "label": "Soft Pin",
        "icon": "control.png",
        "summary": "Pin a rigid body in worldspace, with a spring-like softness.",
        "description": "Guide the selected rigid body towards its current worldspace position. The guide may be animated and disabled/enabled at run-time."
    },
    "mimic": {
        "deprecated": true,
        "label": "Mimic",
        "icon": "mimic.png",
        "summary": "Generate a target control hierarchy for the simulation to follow.",
        "description": "This command walks a hierarchy of rigid bodies and generates an equivalent kinematic hierarchy which you can animate. The simulation can then follow this hierarchy in 3 ways - relatively, like normal chains, absolute or kinematically.",
        "options": [
            "mimicNodeType",
            "mimicExclusive",
            "mimicAddHardPin",
            "mimicAddSoftPin",
            "mimicAddMultiplier",
            "mimicAddUserAttributes",
            "mimicCleanChannelBox",
            "mimicFreezeTransform"
        ]
    },
    "motor": {
        "deprecated": true,
        "label": "Motor",
        "enable": false
    },
    "actuator": {
        "deprecated": true,
        "label": "Actuator",
        "enable": false
    },
    "trigger": {
        "deprecated": true,
        "label": "Trigger",
        "enable": false
    },
    "push": {
        "deprecated": true,
        "label": "Push",
        "icon": "magnet.png",
        "summary": "Push rigids away from a point in space.",
        "description": "This forces applies a force facing away from a point in space. It can be used for things like explosions."
    },
    "pull": {
        "deprecated": true,
        "label": "Pull",
        "icon": "magnet2.png",
        "summary": "Pull rigids towards a point in space.",
        "description": "This is technically the same as 'Push', except the opposite. Instead of pushing rigids away from a point in space, rigids are pull towards it. This can be used for effects like black holes, or to simply nudge a rigid in some specific direction."
    },
    "directional": {
        "deprecated": true,
        "label": "Directional",
        "icon": "uniformforce.png",
        "summary": "Like gravity, except in any arbitrary direction.",
        "description": "Gravity is computed deep within the solver and isn't technically applied as an external force, but apart form that this force replicates gravity in addition to letting you control the direction."
    },
    "wind": {
        "deprecated": true,
        "label": "Wind",
        "icon": "turbulence.png",
        "summary": "Create a force similar to wind, with editable turbulence.",
        "description": "Wind is a complex phenomena. This force applies an iterative, 3D Perlin noise field to rigid bodies and is a great representation of how wind looks and acts in the real world. Use 'Visualiser' to get a sense of how it looks."
    },
    "visualiser": {
        "deprecated": true,
        "label": "Visualiser",
        "icon": "slice.png",
        "summary": "Visualise 3D forces with a 2D slice, much like an MRI.",
        "description": "This creates a 2-dimensonal representation of either all or selected 3-dimensional forces. The slice can be moved and scaled just like any normal Maya transform, and the amount and length of samples can be manipulated (and even animated) interactively to get a fine-grained understanding of what your forces do to each rigid. Hint: Create *multiple* slices at various strategic locations in your scene to get an even greater understanding at specific areas."
    },
    "assignToSelected": {
        "deprecated": true,
        "label": "Assign Force to Selected Rigid(s)",
        "summary": "Assign force to the selected rigids.",
        "description": "Forces are typically assigned to all existing rigids when created, or to the currently selected rigids. This command lets you add forces to rigids manually. Forces can be removed by breaking their connection to each other."
    },
    "emitter": {
        "deprecated": true,
        "label": "Emitter",
        "enable": false
    },
    "character": {
        "deprecated": true,
        "label": "Character",
        "summary": "Generate a character from the selected joint hierarchy.",
        "icon": "ragdoll.png",
        "options": [
            "characterNormalise",
            "characterLabels",
            "characterStopBehaviour"
        ],
        "description": "An auto-rigger, designed to automatically generate an animatable character from a skeletal hierarchy."
    },
    "trajectory": {
        "deprecated": true,
        "label": "Trajectory",
        "enable": false,
        "icon": "trajectory.png"
    },
    "momentOfInertia": {
        "deprecated": true,
        "label": "Moment of Inertia",
        "enable": false
    },
    "centerOfMass": {
        "deprecated": true,
        "label": "Center of Mass",
        "enable": false,
        "icon": "com.png"
    },
    "createDynamicControl": {
        "deprecated": true,
        "hidden": true,
        "label": "Create Dynamic Control",
        "icon": "dynamic_control.png",
        "summary": "Create a new <b>dynamic</b> control from the currently selected <i>regular</i> control(s).",
        "options": [
            "dynamicControlShapeType",
            "dynamicControlAutoBlend",
            "dynamicControlAutoInfluence",
            "dynamicControlAutoMultiplier"
        ],
        "description": "Turn your regular character animation control into a rigid body, where the input animation is used as a dynamic guide for the simulation. The animation remains editable and the final result can be switched or blended between.",
        "media": [
            {
                "label": "Basics",
                "description": "Turn any FK hierarchy into a dynamic chain.",
                "fname": "dynamic_control_1.gif"
            },
            {
                "label": "Every other control",
                "description": "Skip some FK controls, for a simplified dynamic hierarchy.",
                "fname": "dynamic_control_2.gif"
            }
        ]
    },
    "multiplySelected": {
        "deprecated": true,
        "label": "Multiply Selected",
        "icon": "multiply.png",
        "summary": "Multiply keyable attributes on multiple physics objects at once.",
        "options": [],
        "description": "Perform bulk-edits of many rigid or constraint attributes at once, from a single attribute source. For example, edit the `Translate Damping` of all rigid in an entire character, from a single top-level node."
    },
    "multiplyRigids": {
        "deprecated": true,
        "label": "Multiply Selected Rigids",
        "icon": "rigid_multiplier.png",
        "summary": "Multiply keyable attributes on multiple rigid at once.",
        "options": [],
        "description": "Perform bulk-edits of many rigid attributes at once, from a single attribute source. For example, edit the `Translate Damping` of all rigid in an entire character, from a single top-level node."
    },
    "multiplyConstraints": {
        "deprecated": true,
        "label": "Multiply Selected Constraints",
        "icon": "constraint_multiplier.png",
        "summary": "Multiply keyable attributes on multiple constraints at once.",
        "options": [],
        "description": "Like Multiply Rigid, except for constraints."
    },
    "bakeSimulation": {
        "deprecated": true,
        "label": "Bake Simulation",
        "icon": "bake.png",
        "summary": "Convert a live simulation into editable keyframes.",
        "description": "This uses Maya's Bake Simulation tool to convert a simulation into keyframes you can use for further editing.",
        "options": [
            "bakeScene",
            "bakePerformance",
            "bakeRange",
            "bakeStartTime",
            "bakeEndTime",
            "bakeDeletePhysics",
            "bakeUnrollRotation",
            "bakeToLayer",
            "bakeIncludeStatic"
        ]
    },
    "exportPhysics": {
        "label": "Export Physics",
        "icon": "load.png",
        "summary": "Save physics to disk.",
        "description": "Export the internals of the Ragdoll solver into a new file, this file could then be imported back into Maya for re-application onto an identical character or imported elsewhere such as Unreal or Unity.",
        "options": [
            "exportPath",
            "exportThumbnail",
            "exportFormat",
            "exportSolver",
            "exportIncludeAnimation",
            "exportIncludeSimulation"
        ]
    },
    "importPhysics": {
        "label": "Import Physics",
        "icon": "save.png",
        "summary": "Load physics from disk.",
        "description": "Import a previously exported Ragdoll scene from disk.",
        "options": [
            "importPath",
            "importPaths",
            "importMethod",
            "importSolver",
            "importMergePhysics",
            "importPreserveAttributes",
            "importIncludeAnimation",
            "importIncludeSimulation",
            "importUseSelection",
            "importCreateMissingTransforms",
            "importMatchBy",
            "importNamespace",
            "importNamespaceCustom",
            "importSearchAndReplace",
            "importCurrentSelection"
        ]
    },
    "openPhysics": {
        "label": "Open Physics",
        "icon": "physics.png",
        "enable": false,
        "summary": "Generate new Maya scene from .rag file",
        "description": "Be rid of all native Maya nodes and work with pure physics at optimal performance. Export and apply the baked keyframes onto your original, heavy character rig once finished tinkering.",
        "options": [
        ]
    },

    "applyPhysics": {
        "label": "Apply Physics",
        "icon": "physics.png",
        "enable": false,
        "summary": "Import, bake and delete physics from disk.",
        "description": "Eliminate any and all interactions with physics by immediately baking the provided file on import, and deleting physics afterwards. This can be useful for quickly applying physics to tails and such without requiring much up-front control. Or for automating physics altogeher on a farm.",
        "options": [
        ]
    },

    "combineScenes": {
        "deprecated": true,
        "label": "Combine Scenes",
        "icon": "combine.png",
        "summary": "Combine two or more scenes into one.",
        "description": "Move all rigids from two or more scenes into one common scene, where they can interact with each other."
    },
    "extractFromScene": {
        "deprecated": true,
        "label": "Extract Rigids",
        "icon": "extract.png",
        "summary": "Extract rigids into new scene.",
        "description": "Move rigids *out* of one scene and into a new scene, where they can run in parallel with the original, without interacting with each other."
    },
    "moveToScene": {
        "deprecated": true,
        "label": "Move Rigids",
        "icon": "move.png",
        "summary": "Move rigids into existing scene.",
        "description": "Move rigids from one scene into another, where they can interact with other rigids in the destination scene."
    },
    "replaceMesh": {
        "label": "Replace Mesh",
        "icon": "replace.png",
        "summary": "Replace input of the 'Mesh' shape type with another polygonal or NURBS mesh.",
        "description": "Substitute the current input of the 'Mesh' shape type with another. Also taking worldspace into account, so the mesh can be anywhere in the scene, under any group or voodoo magic.",
        "options": [
            "replaceMeshExclusive",
            "replaceMeshMaintainOffset"
        ]
    },
    "freezeEvaluation": {
        "deprecated": true,
        "label": "Freeze",
        "icon": "freeze.png",
        "summary": "Exclude selected node from Maya's Parallel Evaluation.",
        "description": "Optimise performance by excluding nodes from both Ragdoll and Maya's native evaluation. Normally, disabling evaluation of a rigid body excludes this from the simulation. But simulation isn't the primary bottleneck, evaluating transforms are. Simply having a series of parented controls means Maya is forced to evaluate them serially, in order. Parents first. For deep hierarchies this can be very expensive. Freezing allows you to explicitly tell Maya 'hey, don't bother' which can increase performance. This really only works on when freezing a hierarchy all the way to its leaf. Freezing an elbow but leaving the hand for example will unlikely have an effect, you'd need to freeze the whole arm.",
        "options": [
            "freezeSelection",
            "freezeSelectionHierarchy",
            "freezeSelectionShapesOnly"
        ]
    },

    "unfreezeEvaluation": {
        "deprecated": true,
        "label": "Unfreeze",
        "icon": "unfreeze.png",
        "summary": "Undo the effect of freezing evaluation.",
        "options": [
            "freezeSelection",
            "freezeSelectionHierarchy",
            "freezeSelectionShapesOnly"
        ]
    },

    "editConstraintFrames": {
        "label": "Edit Constraint Pivots",
        "icon": "frame.png",
        "summary": "Edit the parent and child pivots using native Maya transforms",
        "description": "Create editable transforms for the parent and child pivots for the selected constraint, or constraint under the selected transform. The parent frame represents the position and orientation the child rigid is connected, and vice versa."
    },
    "constraintEditor": {
        "deprecated": true,
        "label": "Open Pivot Editor",
        "icon": "rotate.png",
        "summary": "Visually manipulate constraint pivots with this UI",
        "description": "Use this graphical user interface to manipulate constraint pivots interactively."
    },

    "resetConstraintFrames": {
        "label": "Reset Constraint Frames",
        "icon": "reset_constraint.png",
        "summary": "Reset constraint frames to their defaults",
        "description": "Set the frames of a constraint such that twist rotates a rigid along its length."
    },

    "editShape": {
        "deprecated": true,
        "label": "Edit Shape",
        "icon": "rigid.png",
        "summary": "Edit the shape offset and shape rotation attributes with a native Maya transform.",
        "description": "Create editable transforms for the shape attributes to simplify editing with the native interactive Maya manipulators."
    },
    "duplicateSelected": {
        "deprecated": true,
        "label": "Duplicate Selected",
        "icon": "duplicate.png",
        "summary": "Create a new rigid, using the selected rigid as a template for position, orientation and shape."
    },
    "transferAttributes": {
        "deprecated": true,
        "label": "Transfer Attributes",
        "icon": "transfer_attributes.png",
        "summary": "Copy attributes from one rigid body to another.",
        "description": "Copy attributes from the first selected rigid to the second selected rigid, like shape extents and constraint frames. This can be used to mirror one rigid across a character."
    },
    "convertToPolygons": {
        "deprecated": true,
        "label": "Convert to Polygons",
        "icon": "convert.png",
        "summary": "Convert selected rigids and controls into polygons.",
        "description": "(Unstable) Convert the selected <code>rdRigid</code> and <code>rdControl</code> nodes into geometry that can be exported to another application, and rendered with shadows in the viewport. NOTE: This may crash your scene, use at your own risk."
    },
    "normaliseShapes": {
        "deprecated": true,
        "label": "Normalise Shapes",
        "summary": "Resize shapes within a hierarchy to avoid some being too different.",
        "description": "Resize shapes across the selected hierarchy such that no shape is overly sized relative another. This is mostly intended for use with the Character command, to automatically generate a suitable skeleton. It is however not very good at the moment (!)."
    },
    "setInitialState": {
        "deprecated": true,
        "label": "Set Initial State",
        "icon": "initial_state.png",
        "summary": "Re-establish the starting position and orientation of selected rigids.",
        "description": "You can edit the position and orientation of an active rigid, but the changes won't take effect until you set the initial state. This records the position of the rigid bodies, wherever they are, at any time, as the starting position and orientation the next time you hit play.",
        "options": [
            "initialStateUseSelection"
        ]
    },
    "clearInitialState": {
        "deprecated": true,
        "label": "Clear Initial State",
        "icon": "initial_state2.png",
        "summary": "Set initial state to creation state.",
        "description": "Whenever you create a new rigid, the current translate/rotate values are stored in the `.creationMatrix` attribute. This command writes this original matrix back into the `.restMatrix` attribute.",
        "options": [
            "initialStateUseSelection"
        ]
    },
    "deleteAllPhysics": {
        "label": "Delete Physics",
        "icon": "delete.png",
        "summary": "Clear the Maya scene of anything related to Ragdoll.",
        "description": "Clear the Maya scene of anything related to Ragdoll. This can be useful for getting a clean slate, or to debug whether the problem you are experiencing is related to Ragdoll.",
        "options": [
            "deleteFromSelection"
        ]
    },
    "explorer": {
        "label": "Ragdoll Explorer",
        "icon": "internals.png",
        "summary": "Explore the internals of the solver.",
        "description": "Ragdoll Explorer is a user interface for contents coming out of cmds.ragdollDump(). That is, the solver internals used for export to another application.",
        "options": []
    },
    "globalPreferences": {
        "label": "Ragdoll Preferences",
        "icon": "system.png",
        "summary": "Edit global Ragdoll preferences, like the scale at which Ragdoll draws things.",
        "description": "Edit the scale of manipulators and visual elements of Ragdoll, especially constriants. If you work at a scale other than Maya's currently set units, this command is your friend.",
        "options": [
            "scale",
            "sceneScale",
            "cacheMedia",
            "globalsValidations",
            "validateEvaluationMode",
            "validateCachingMode",
            "validateLegacyOpenGL2",
            "validateScalePivot",
            "validatePlaybackSpeed",
            "reloadShaders"
        ]
    },
    "selectInvalidConstraints": {
        "deprecated": true,
        "label": "Select Invalid Constraints",
        "icon": "save.png",
        "summary": "Select constraints without connected rigid bodies."
    },
    "savePreferences": {
        "label": "Save Preferences",
        "icon": "save.png",
        "summary": "Save Ragdoll preferences to disk.",
        "description": "Ragdoll preferences are stored alongside Maya's preferences. So clearing those would also clear Ragdoll's preferences."
    },
    "resetPreferences": {
        "label": "Reset Preferences",
        "icon": "load.png",
        "summary": "Restore Ragdoll preferences to their default values.",
        "description": "This doesn't save preferences, something to keep in mind."
    },
    "selectRigids": {
        "deprecated": true,
        "label": "Select Rigids",
        "icon": "rigid.png",
        "summary": "Select all rigids, or filter rigids from selection.",
        "description": "Either select some hierarchy of nodes and use this to isolate only the rigids in that hierarchy, or deselect everything and then call it to select every single rigid in the scene.",
        "options": [
            "selectUseSelection"
        ]
    },
    "selectConstraints": {
        "deprecated": true,
        "label": "Select Constraints",
        "icon": "constraint.png",
        "summary": "Select all constraints, or filter constraints from selection.",
        "description": "Either select some hierarchy of nodes and use this to isolate only the constraints in that hierarchy, or deselect everything and then call it to select every single constraint in the scene.",
        "options": [
            "selectUseSelection"
        ]
    },
    "selectScenes": {
        "deprecated": true,
        "label": "Select Scenes",
        "icon": "logo.png",
        "summary": "Select all scenes, or filter scenes from selection.",
        "description": "Either select some hierarchy of nodes and use this to isolate only the scenes in that hierarchy, or deselect everything and then call it to select every single constraint in the scene.",
        "options": [
            "selectUseSelection"
        ]
    },
    "selectControls": {
        "deprecated": true,
        "label": "Select Controls",
        "icon": "control.png",
        "summary": "Select all controls, or filter controls from selection.",
        "description": "Either select some hierarchy of nodes and use this to isolate only the controls in that hierarchy, or deselect everything and then call it to select every single constraint in the scene.",
        "options": [
            "selectUseSelection"
        ]
    },
    "ragdoll": {
        "icon": "logo.png",
        "summary": "View your version, and eventually look for updates and tutorials. Not yet though."
    },


    "#": "---------",
    "#": " Markers ",
    "#": "---------",


    "assignMarker": {
        "label": "Assign",
        "icon": "marker.png",
        "summary": "Assign marker to this node",
        "description": "Add a unique marker to the selected node, such that Ragdoll can find and simulate it.",
        "options": [
            "markersAssignSolver",
            "markersAssignGroup",
            "markersDensity",
            "markersAutoLimit",
            "markersCreateGround",
            "markersCreateObjectSet",
            "markersCreateLollipop",

            "channelBoxSeparator",

            "markersChannelBoxMaterial",
            "markersChannelBoxShape",
            "markersChannelBoxLimit",
            "useProxyAttributes"
        ]
    },

    "assignGroup": {
        "label": "Assign and Connect",
        "icon": "marker_group.png",
        "summary": "Assign marker to this group of nodes",
        "description": "Add a series of markers to the selected nodes, such that Ragdoll can find and simulate the hierarchy it creates.",
        "options": [
            "markersAssignSolver",
            "markersAssignGroup",
            "markersDensity",
            "markersAutoLimit",
            "markersCreateGround",
            "markersCreateObjectSet",
            "markersCreateLollipop",

            "channelBoxSeparator",

            "markersChannelBoxMaterial",
            "markersChannelBoxShape",
            "markersChannelBoxLimit",
            "useProxyAttributes"
        ]
    },

    "assignHierarchy": {
        "label": "Assign to Hierarchy",
        "enable": false,
        "icon": "hierarchy.png",
        "summary": "Assign marker to this group of nodes",
        "description": "Add a series of markers to the selected nodes, such that Ragdoll can find and simulate the hierarchy it creates.",
        "options": [
            "markersCreateGround",
            "markersCreateObjectSet",
            "markersAutoLimit",
            "markersCreateLollipop"
        ]
    },

    "groupMarkers": {
        "label": "Group",
        "icon": "group.png",
        "summary": "Group the selected markers",
        "description": "Create a new group containing the currently selected markers. The group carries settings that affect all members within that group, such as Stiffness and Damping.",
        "options": []
    },

    "ungroupMarkers": {
        "label": "Ungroup",
        "icon": "ungroup.png",
        "summary": "Ungroup the selected markers",
        "description": "Remove markers from their group, making them standalone.",
        "options": []
    },

    "assignConstraint": {
        "label": "Assign Constraint",
        "icon": "orient_constraint.png",
        "summary": "Constrain the two selected markers",
        "description": "Create a new constraint between the two selected markers.",
        "options": [
        ]
    },

    "distanceConstraint": {
        "label": "Distance Constraint",
        "icon": "distance.png",
        "summary": "Constrain the distance between two markers",
        "description": "Create a new constraint between the two selected markers.",
        "options": [
        ]
    },

    "fixedConstraint": {
        "label": "Weld Constraint",
        "icon": "fixed_constraint.png",
        "summary": "Constrain the position and orientation between two markers",
        "description": "Create a new constraint between the two selected markers.",
        "options": [
        ]
    },

    "pinConstraint": {
        "label": "Pin Constraint",
        "icon": "softpin.png",
        "summary": "Softly constrain the position and orientation of a marker in worldspace",
        "description": "Create a new pin constraint between the selected marker and the world.",
        "options": [
        ]
    },

    "mimicConstraint": {
        "label": "Mimic Constraint",
        "icon": "mimic.png",
        "summary": "Generate a hierarchy of local soft pins",
        "description": "Create a new mimic starting at the selected marker.",
        "options": [
        ]
    },

    "recordMarkers": {
        "label": "Record Simulation",
        "icon": "record.png",
        "summary": "Transfer simulation into animation",
        "description": "Record the simulation as animation onto the marker targets.",
        "options": [
            "markersRecordRange",
            "markersRecordCustomStartTime",
            "markersRecordCustomEndTime",
            "markersRecordFilter",
            "markersRecordMaintainOffset2",
            "markersRecordToLayer",
            "markersUseSelection",
            "markersIgnoreJoints",
            "markersRecordKinematic",
            "markersRecordProtectOriginalInput",
            "markersRecordReset",
            "markersRecordMode"
        ]
    },

    "snapMarkers": {
        "label": "Snap to Simulation",
        "icon": "snap.png",
        "summary": "Snap animation to simulation",
        "description": "Move animation to where the simulation is right now.",
        "options": [
            "markersUseSelection",
            "markersIgnoreJoints",
            "markersRecordFilter",
            "markersRecordMaintainOffset2"
        ]
    },

    "markersManipulator": {
        "label": "Manipulator",
        "icon": "manipulator.png",
        "summary": "Interactively edit the contents of a solver",
        "description": "Toggle visibility of the various manipulators accessible to you, such that you can edit them interactively rather than via the Channel Box.",
        "options": [
        ]
    },

    "markersAutoLimit": {
        "label": "Auto Limit",
        "icon": "orient_constraint.png",
        "summary": "Automatically transfer locked rotate channels into Ragdoll limits",
        "description": "Determine how to replicate the locked Maya channels in physics using the rotate limits of a marker.",
        "options": [
            "markersDensity"
        ]
    },

    "extractMarkers": {
        "label": "Extract Simulation",
        "icon": "exoskeleton2.png",
        "summary": "Extract simulation from markers",
        "description": "Generate a joint hierarchy for each marker along with the baked simulation.",
        "options": [
            "markersExtractAndAttach"
        ]
    },

    "retargetMarker": {
        "label": "Retarget Marker",
        "icon": "retarget.png",
        "summary": "Change where to record the selected marker",
        "description": "When recording, this is where keyframes go. Typically this is from e.g. a joint to an animation control, but can also be from the same control that was assigned a marker.",
        "options": [
            "markersAppendTarget"
        ]
    },

    "reassignMarker": {
        "label": "Reassign Marker",
        "icon": "reassign.png",
        "summary": "Change the input to the selected marker",
        "description": "",
        "options": [
        ]
    },

    "reparentMarker": {
        "label": "Reparent Marker",
        "icon": "reparent.png",
        "summary": "Change the parent of the selected marker",
        "description": "",
        "options": []
    },

    "unparentMarker": {
        "label": "Unparent Marker",
        "icon": "extract.png",
        "summary": "Remove the parent from the selected marker",
        "description": "",
        "options": []
    },

    "untargetMarker": {
        "label": "Untarget Marker",
        "icon": "untarget.png",
        "summary": "Remove all output from the selected marker",
        "description": "",
        "options": []
    },

    "resetMarkerConstraintFrames": {
        "label": "Reset Constraint Frames",
        "icon": "reset_constraint.png",
        "summary": "Reset constraint frames to their defaults",
        "description": "Set the frames of a constraint such that twist rotates a rigid along its length."
    },

    "editMarkerConstraintFrames": {
        "label": "Edit Constraint Frames",
        "icon": "frame.png",
        "summary": "Edit constraint frames manually",
        "description": "Generate two locators to manipulate the parent and child frames of a Marker. This is an advanced topic, use at your own risk, and use Reset Constraint Frames if making a mistake."
    },

    "toggleChannelBoxAttributes": {
        "label": "Toggle Channel Box Attributes",
        "icon": "attributes.png",
        "summary": "Expose (or unexpose) more attributes for your Markers",
        "description": "Make non-keyable attributes relevant to authoring of Markers visible in the Channel Box, such as Mass and Length.",
        "options": [
            "markersChannelBoxMaterial",
            "markersChannelBoxShape",
            "markersChannelBoxLimit"
        ]
    },

    "markerReplaceMesh": {
        "label": "Replace Mesh",
        "icon": "replace.png",
        "summary": "Replace input of the 'Mesh' shape type with another polygonal or NURBS mesh.",
        "description": "Substitute the current input of the 'Mesh' shape type with another. Also taking worldspace into account, so the mesh can be anywhere in the scene, under any group or voodoo magic.",
        "options": [
            "replaceMeshMaintainOffset",
            "replaceMeshMaintainHistory"
        ]
    },

    "parentMarker": {
        "label": "Parent Marker",
        "icon": "parent.png",
        "summary": "Select the parent of this marker",
        "description": "",
        "options": [
        ]
    },

    "childMarkers": {
        "label": "Child Markers",
        "icon": "children.png",
        "summary": "Select the children of this marker",
        "description": "",
        "options": [
        ]
    },

    "selectMarkers": {
        "label": "Select Markers",
        "icon": "marker.png",
        "summary": "Select all markers in the scene.",
        "description": "Select all markers in the scene.",
        "options": [
        ]
    },

    "selectGroups": {
        "label": "Select Groups",
        "icon": "suit.png",
        "summary": "Select all groups in the scene.",
        "description": "Select all groups in the scene.",
        "options": [
        ]
    },

    "selectSolvers": {
        "label": "Select Solvers",
        "icon": "solver.png",
        "summary": "Select all solvers in the scene.",
        "description": "Select all solvers in the scene.",
        "options": [
        ]
    },

    "createLollipop": {
        "label": "Create Lollipop",
        "icon": "lollipop.png",
        "summary": "Create a new lollipop for the selected marker.",
        "description": "This creates a new lollipop for the marker such that it becomes easier to find in the viewport and Channel Box.",
        "options": [
        ]
    },

    "cacheSolver": {
        "label": "Cache Solver",
        "icon": "bake.png",
        "summary": "Cache the entire simulation of a solver",
        "description": "This enables caching on all solvers, and runs through the current time to cache all of it.",
        "options": [
        ]
    },

    "uncacheSolver": {
        "label": "Uncache Solver",
        "icon": "unbake.png",
        "summary": "Remove the cache for a solver",
        "description": "This disables and clears the cache on a solver.",
        "options": [
        ]
    },

    "snapToSim": {
        "label": "Snap to Sim",
        "icon": "mimic.png",
        "summary": "Snap marked controls to simulation.",
        "description": "Translate and rotate marked controls to wherever the simulation is at the moment. Useful for partially recording only the current pose.",
        "options": [
        ]
    },

    "linkSolver": {
        "label": "Link Solver",
        "icon": "link.png",
        "summary": "Simulate two or more solvers as one.",
        "description": "Make markers from one solver participate in the simulation of another, such that they can interact. Useful for e.g. referencing two or more characters with their own solvers into one Maya scene, and still have them collide and be constrained to each other.",
        "options": [
        ]
    },

    "unlinkSolver": {
        "label": "Unlink Solver",
        "icon": "unlink.png",
        "summary": "Simulate previously linked solvers separately.",
        "description": "Restore an independent behavior of a linked solver.",
        "options": [
        ]

    },

    "#": "---------",
    "#": " Logging ",
    "#": "---------",

    "loggingOff": {
        "label": "Logging Off",
        "hidden": true,
        "summary": "Stay quiet."
    },
    "loggingDebug": {
        "label": "More Logging",
        "hidden": true,
        "summary": "Print all messages you can think of."
    },
    "loggingInfo": {
        "label": "Default Logging",
        "hidden": true,
        "summary": "Print only messages that may be interesting, but probably aren't."
    },
    "loggingWarning": {
        "label": "Less Logging",
        "hidden": true,
        "summary": "Don't print anything unless it's something I need to pay attention to."
    }
}
